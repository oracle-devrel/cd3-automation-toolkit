import pandas as pd
import os
import shutil
import datetime
import ssl
import sys
import pathlib
import urllib.request
import oci
from oci.identity import IdentityClient
from oci.config import DEFAULT_LOCATION
from openpyxl import load_workbook
from openpyxl.styles import PatternFill
from openpyxl.styles import Alignment
from openpyxl.styles import Border
from openpyxl.styles import Side
from contextlib import contextmanager
import xml.etree.ElementTree as ET
import collections
import re
import json as simplejson
import warnings
import threading
warnings.simplefilter("ignore")

def data_frame(filename,sheetname):

    # Read the tab from excel, Drop null values, Reset index
    df, col_headers = commonTools.read_cd3(filename, sheetname)
    df = df.dropna(how='all')
    df = df.reset_index(drop=True)

    return df


class commonTools():
    endNames = {'<END>', '<end>', '<End>'}
    tagColumns = {'freeform tags', 'freeform_tags', 'defined_tags', 'defined tags',
                  'vnic defined tags','vnic_defined_tags', 'vnic freeform tags', 'vnic_freeform_tags',
                  'oke_labels', 'oke labels', 'nodepool defined tags', 'nodepool_defined_tags', 'node defined tags',
                  'node_defined_tags', 'nodepool freeform tags', 'nodepool_freeform_tags', 'node freeform tags',
                  'node_freeform_tags','lb defined tags', 'lb_defined_tags', 'lb freeform tags', 'lb_freeform_tags',
                  'volume defined tags', 'volume_defined_tags', 'volume freeform tags', 'volume_freeform_tags',
                  'subscription defined tags', 'subscription_defined_tags', 'subscription freeform tags','subscription_freeform_tags'}

    drg_auto_RTs = {'Autogenerated Drg Route Table for RPC, VC, and IPSec attachments', 'Autogenerated Drg Route Table for VCN attachments'}
    drg_auto_RDs = {'Autogenerated Import Route Distribution for ALL routes', 'Autogenerated Import Route Distribution for VCN Routes'}

    def setInputParameters(self, prefix, outdir, inputfile, tf_or_tofu):
        self.prefix = prefix
        self.outdir = outdir
        self.inputfile = inputfile
        self.tf_or_tofu = tf_or_tofu


    #Read Regions and Protocols Files and Excel_Columns and create dicts
    def __init__(self):
        self.all_regions=[]
        self.home_region=""
        self.ntk_compartment_ids = {}
        self.domain_data = {}
        self.region_dict={}
        self.region_ad_dict = {}
        self.protocol_dict={}
        self.sheet_dict={}
        self.domain_filter = None
        self.identity_domain_enabled = False
        self.reg_filter = None
        self.comp_filter = None
        self.tag_filter = None
        self.vizoci_comp_filter = None
        self.default_dns = None
        self.generate_graphs = None
        self.ins_pattern_filter = None
        self.ins_ad_filter = None
        self.bv_pattern_filter = None
        self.bv_ad_filter = None
        self.orm_reg_filter = None
        self.vizoci_reg_filter = None
        self.orm_comp_filter = None
        self.vault_region = None
        self.vault_comp = None
        self.budget_amount = None
        self.budget_threshold = None
        self.cg_region = None
        self.fwl_clone_src_region = None
        self.src_policy_str = None
        self.target_policy_str = None
        self.fwl_region = None
        self.fwl_name = None
        self.fwl_clone_comp = None
        self.fwl_del_comp = None
        self.fwl_pol_pattern_filter = None
        self.attached_policy_only = None

        self.fsdr_ex_filename = None
        self.fsdr_ex_sheet = None
        self.fsdr_ex_ocid = None
        self.fsdr_up_filename = None
        self.fsdr_up_sheet = None
        self.fsdr_up_ocid = None

        self.prefix=''
        self.outdir=''
        self.inputfile=''
        self.tf_or_tofu = ''

        # When called from wthin OCSWorkVM or user-scripts
        dir=os.getcwd()
        if ("OCSWorkVM" in os.getcwd() or 'user-scripts' in os.getcwd()):
            os.chdir("../")
        regionFileName="OCI_Regions"
        protocolFileName="OCI_Protocols"
        excelColumnName="Excel_Columns"
        with open (regionFileName) as f:
            for line in f:
                if("#" not in line and ":" in line):
                    key = line.split(":")[0].strip().lower()
                    val = line.split(":")[1].strip().lower()
                    self.region_dict[key] = val

        with open(protocolFileName) as f:
            for line in f:
                if ("#" not in line and ":" in line):
                    key=line.split(":")[0].strip()
                    val=line.split(":")[1].strip()
                    self.protocol_dict[key]=val

        #Get Dict for column names
        with open(excelColumnName) as f:
            s = f.read()
        while True:
            decoder = simplejson.JSONDecoder()
            obj, end = decoder.raw_decode(s)
            self.sheet_dict = dict(obj)
            break

        #Change back to Initial
        if ("OCSWorkVM" in dir):
            os.chdir(dir)
        #os.chdir(dir)
    # Get Export filters
    def get_export_filters(self,export_filters):
        for i in export_filters:
            i = i.replace(" ", "")
            i = i.replace("\"", "")
            if 'reg_filter' in i:
                self.reg_filter = (i.split("=")[1])[2:][:-2]
            if 'comp_filter' in i:
                self.comp_filter = (i.split("=")[1])[2:][:-2]
                self.comp_filter = self.comp_filter if self.comp_filter else "null"
            if 'tag_filter' in i:
                self.tag_filter = (i.split("=",1)[1])[2:][:-2]

            if 'vizoci_comp_filter' in i:
                self.vizoci_comp_filter = (i.split("=")[1])[2:][:-2]
                self.vizoci_comp_filter = self.vizoci_comp_filter if self.vizoci_comp_filter else "null"

            if 'domain_filter' in i:
                self.domain_filter = (i.split("=")[1])[2:][:-2]
                self.domain_filter = self.domain_filter if self.domain_filter else "null"

            if 'default_dns' in i:
                self.default_dns = (i.split("=")[1])[2:][:-2]

            if 'generate_graphs' in i:
                self.generate_graphs = (i.split("=")[1])[2:][:-2]

            if 'ins_pattern_filter' in i:
                self.ins_pattern_filter = (i.split("=")[1])[2:][:-2]

            if 'ins_ad_filter' in i:
                self.ins_ad_filter = (i.split("=")[1])[2:][:-2]

            if 'bv_pattern_filter' in i:
                self.bv_pattern_filter = (i.split("=")[1])[2:][:-2]

            if 'bv_ad_filter' in i:
                self.bv_ad_filter = (i.split("=")[1])[2:][:-2]

            if 'orm_region' in i:
                self.orm_reg_filter = (i.split("=")[1])[2:][:-2]

            if 'vizoci_reg_filter' in i:
                self.vizoci_reg_filter = (i.split("=")[1])[2:][:-2]

            if 'orm_compartments' in i:
                self.orm_comp_filter = (i.split("=")[1])[2:][:-2]
                self.orm_comp_filter = self.orm_comp_filter if self.orm_comp_filter else "null"


            if 'vault_region' in i:
                self.vault_region = (i.split("=")[1])[2:][:-2]

            if 'vault_comp' in i:
                self.vault_comp = (i.split("=")[1])[2:][:-2]

            if 'budget_amount' in i:
                self.budget_amount = (i.split("=")[1])[2:][:-2]

            if 'budget_threshold' in i:
                self.budget_threshold = (i.split("=")[1])[2:][:-2]

            if 'cg_region' in i:
                self.cg_region = (i.split("=")[1])[2:][:-2]

            if 'fwl_clone_src_region' in i:
                self.fwl_clone_src_region = (i.split("=")[1])[1:][:-1]

            if 'src_policy_str' in i:
                self.src_policy_str = (i.split("=")[1])[2:][:-2]

            if 'target_policy_str' in i:
                self.target_policy_str = (i.split("=")[1])[2:][:-2]

            if 'fwl_region' in i:
                self.fwl_region = (i.split("=")[1])[2:][:-2]

            if 'fwl_name' in i:
                self.fwl_name = (i.split("=")[1])[2:][:-2]

            if 'fwl_clone_comp' in i:
                self.fwl_clone_comp = (i.split("=")[1])[1:][:-1]
                self.fwl_clone_comp = self.fwl_clone_comp if self.fwl_clone_comp else "null"

            if 'fwl_del_comp' in i:
                self.fwl_del_comp = (i.split("=")[1])[2:][:-2]
                self.fwl_del_comp = self.fwl_del_comp if self.fwl_del_comp else "null"

            if 'fwl_pol_pattern_filter' in i:
                self.fwl_pol_pattern_filter = (i.split("=")[1])[2:][:-2]

            if 'attached_policy_only' in i:
                self.attached_policy_only = (i.split("=")[1])[2:][:-2]

            if 'fsdr_ex_filename' in i:
                self.fsdr_ex_filename = (i.split("=")[1])[2:][:-2]
            if 'fsdr_ex_sheet' in i:
                self.fsdr_ex_sheet = (i.split("=")[1])[2:][:-2]
            if 'fsdr_ex_ocid' in i:
                self.fsdr_ex_ocid = (i.split("=")[1])[2:][:-2]
            if 'fsdr_up_filename' in i:
                self.fsdr_up_filename = (i.split("=")[1])[2:][:-2]
            if 'fsdr_up_sheet' in i:
                self.fsdr_up_sheet = (i.split("=")[1])[2:][:-2]
            if 'fsdr_up_ocid' in i:
                self.fsdr_up_ocid = (i.split("=")[1])[2:][:-2]


    # OCI API Authentication
    def authenticate(self,auth_mechanism,config_file_path=DEFAULT_LOCATION):
        signer = None

        try:
            config = oci.config.from_file(file_location=config_file_path)
        except Exception as e:
            print(str(e))
            print(".....Exiting!!!")
            exit(0)

        if auth_mechanism == 'api_key':
            signer = oci.signer.Signer(config['tenancy'],config['user'],config['fingerprint'],config['key_file'])
        elif auth_mechanism == 'session_token':
            token_file = config['security_token_file']
            token = None
            with open(token_file, 'r') as f:
                token = f.read()

            private_key = oci.signer.load_private_key_from_file(config['key_file'])
            signer = oci.auth.signers.SecurityTokenSigner(token, private_key)
        elif auth_mechanism == 'instance_principal':
            signer = oci.auth.signers.InstancePrincipalsSecurityTokenSigner()

        return config,signer

    #Get Region ADs
    def get_region_ad_dict(self, config, signer):
        for reg in self.all_regions:
            ADs = []
            config.__setitem__("region", self.region_dict[reg])
            idc = IdentityClient(config=config, retry_strategy=oci.retry.DEFAULT_RETRY_STRATEGY, signer=signer)
            ADs_data = idc.list_availability_domains(compartment_id=config['tenancy'])
            for AD in ADs_data.data:
                ADs.append(AD.name)
            self.region_ad_dict[reg] = ADs

    #Get Tenancy Regions
    def get_subscribedregions(self, config,signer):
        #Get config client
        #config = oci.config.from_file(file_location=configFileName)
        idc = IdentityClient(config=config, retry_strategy=oci.retry.DEFAULT_RETRY_STRATEGY,signer=signer)
        regionsubscriptions = idc.list_region_subscriptions(tenancy_id=config['tenancy'])
        homeregion=""
        for rs in regionsubscriptions.data:
            if (rs.is_home_region == True):
                homeregion = rs.region_name
            for k, v in self.region_dict.items():
                if (homeregion!="" and v == homeregion):
                    self.home_region = k
                if (rs.region_name == v):
                    self.all_regions.append(k)
                    break

        # return subs region list to caller
        subs_region_list = []
        for reg in regionsubscriptions.data:
            status = getattr(reg, 'status')
            if status == "READY":
                region_name = getattr(reg, 'region_name')
                subs_region_list.append(region_name.split("-")[1])
        return subs_region_list

    #Get Compartment OCIDs
    def get_network_compartment_ids(self,c_id, c_name,config, signer):
        # Get config client

        tenancy_id=config['tenancy']
        idc = IdentityClient(config=config,retry_strategy=oci.retry.DEFAULT_RETRY_STRATEGY,signer=signer)
        compartments = oci.pagination.list_call_get_all_results(idc.list_compartments,compartment_id=c_id, compartment_id_in_subtree=False)

        for c in compartments.data:
            if c.lifecycle_state == "ACTIVE":
                if (c_name != "root"):
                    name = c_name + "::" + c.name
                else:
                    name = c.name
                self.ntk_compartment_ids[name] = c.id
                # Put individual compartment names also in the dictionary
                if (name != c.name):
                    if c.name not in self.ntk_compartment_ids.keys():
                        self.ntk_compartment_ids[c.name] = c.id
                    else:
                        # Remove the individual name added to dict as it is duplicate only if its parent comp is not root
                        c_details = idc.get_compartment(self.ntk_compartment_ids[c.name]).data
                        if (c_details.compartment_id != tenancy_id):
                            self.ntk_compartment_ids.pop(c.name)

                self.get_network_compartment_ids(c.id, name,config,signer)

        self.ntk_compartment_ids["root"]=tenancy_id
        del tenancy_id
        del idc
        del config

    def get_compartment_map(self, var_file, resource_name):
        var_ocids = {}
        ntk_only_resources = ["Validator", "RM", "Compartments","Budgets"]
        try:
            with open(var_file, 'r') as f:
                soc = False
                for line in f:
                    if not soc:
                        if line.strip().startswith('#START_compartment_ocids#'):
                            soc = True
                    elif line.strip().startswith('#compartment_ocids_END#'):
                        soc = False
                    elif "=" in line:
                        line_items = str(line.strip()).split('=')
                        key = str(line_items[0]).strip()
                        value = str(line_items[1]).strip()
                        val=value.split('"')[1]
                        var_ocids[key] = val
                        self.ntk_compartment_ids[key.replace('--', '::')] = val

            f.close()
            #if len(var_ocids) == 0:
            #    print("Please make sure to execute the script for 'Fetch Compartments OCIDs to variables file' under 'CD3 Services' menu option first and re-run this.")
            #    exit(1)

        except Exception as e:
            print(str(e))
            print("Exiting!!!")
            #print("Please fetch compartments first from CD3 Services option from main menu")
            exit(1)
        if resource_name in ntk_only_resources:
            if resource_name == "Validator":
                return var_ocids
            else:
                pass
        else:
            print("\n")
            if resource_name in ["Compartments","IAM Policies","IAM Groups","IAM Users","Network Sources","Tagging Objects"]:
                input_compartment_names = None
            elif resource_name == "Clone Firewall Policy":
                compartment_list_str = "Enter name of the Compartment (as it appears in OCI) of the Firewall Policy to be cloned: "
                if self.fwl_clone_comp == "null":
                    compartments = None
                else:
                    compartments = self.fwl_clone_comp if self.fwl_clone_comp else input(compartment_list_str.format(resource_name))
                input_compartment_names = list(
                    map(lambda x: x.strip(), compartments.split(','))) if compartments else None
            elif resource_name == "Delete Firewall Policy":
                compartment_list_str = "Enter name of the Compartment (as it appears in OCI) of the Firewall Policy to be deleted: "
                if self.fwl_del_comp == "null":
                    compartments = None
                else:
                    compartments = self.fwl_del_comp if self.fwl_del_comp else input(compartment_list_str.format(resource_name))
                input_compartment_names = list(
                    map(lambda x: x.strip(), compartments.split(','))) if compartments else None

            elif resource_name == "VizOCI":
                compartment_list_str = "Enter name of the Compartment (as it appears in OCI) for which you want to run {};\nPress 'Enter' to run for all the Compartments: "
                if self.vizoci_comp_filter == "null":
                    compartments = None
                else:
                    compartments = self.vizoci_comp_filter if self.vizoci_comp_filter else input(compartment_list_str.format(resource_name))
                input_compartment_names = list(
                    map(lambda x: x.strip(), compartments.split(','))) if compartments else None

            else:
                compartment_list_str = "Enter name of Compartment as it appears in OCI (comma separated without spaces if multiple) for which you want to export {};\nPress 'Enter' to export from all the Compartments: "
                if self.comp_filter == "null":
                    compartments = None
                else:
                    compartments = self.comp_filter if self.comp_filter else input(compartment_list_str.format(resource_name))
                input_compartment_names = list(map(lambda x: x.strip(), compartments.split(','))) if compartments else None

            comp_list_fetch = []
            print("\n")

            if input_compartment_names is not None:
                for comp_name in input_compartment_names:
                    var_comp_name = comp_name.replace('::', '--')

                    if var_comp_name not in var_ocids.keys():
                        print("Please check if " + comp_name + " exists in OCI.\nIf yes then Please make sure to execute the script for 'Fetch Compartments OCIDs to variables file' under 'CD3 Services' menu option first and re-run this")
                        exit(1)
                    else:
                        #self.ntk_compartment_ids[comp_name] = var_ocids[var_comp_name]
                        comp_list_fetch.append(comp_name)

                print("Fetching " + resource_name + " for Compartments " + str(comp_list_fetch))
            else:
                print("Fetching " + resource_name + " for all Compartments...")
                comp_ocids = []
                for key, val in var_ocids.items():
                    if val not in comp_ocids:
                        comp_ocids.append(val)
                        #self.ntk_compartment_ids[key.replace('--', '::')] = val
                        comp_list_fetch.append(key.replace('--', '::'))

            return comp_list_fetch

    def identity_domain_check(self,config, signer):
        config.__setitem__("region", self.region_dict[self.home_region])
        idc = IdentityClient(config=config, retry_strategy=oci.retry.DEFAULT_RETRY_STRATEGY, signer=signer)
        try:
            domain = idc.list_domains(config["tenancy"]).data
            self.identity_domain_enabled = True
        except Exception as e:
            print("Tenancy is not Identity Domain Enabled")
            self.identity_domain_enabled = False



    def get_identity_domain_data(self,config, signer, resource,var_file):

        config.__setitem__("region",self.region_dict[self.home_region])
        selected_domains_data = {}
        idc = IdentityClient(config=config, retry_strategy=oci.retry.DEFAULT_RETRY_STRATEGY, signer=signer)
        self.identity_domain_check(config, signer)
        if self.identity_domain_enabled:
            resource = "Identity Domain Resource"
            compartments = self.get_compartment_map(var_file, resource)
            domain_str = "Enter the ',' separated Domain names to export the groups OR Enter 'all' to export from all domains OR leave it Blank to export from default domain : "
            if self.domain_filter == "null":
                domains = None
            else:
                domains = self.domain_filter if self.domain_filter else input(domain_str)
            domain_names = list(map(str.lower,domains.split(',') if domains else ['Default']))

            for compartment in compartments:
                comp_id = self.ntk_compartment_ids[compartment]
                domain = idc.list_domains(comp_id).data
                for d in domain:
                    domain_key = compartment + "@" + d.display_name
                    if 'all' in domain_names or str(d.display_name).lower() in domain_names:
                        self.domain_data[domain_key] = d.url
            if self.domain_data == {}:
                print(f'Input domain does not match in input compartments')

        else:
            self.domain_data = {}

        return self.domain_data

    #Check value exported
    #If None - replace with ""
    #If list, convert to comma sepearted string
    def check_exported_value(value):
        if value == None:
            value = ""
        if ("list" in str(type(value))):
            str1 = ""
            if(value.__len__()==0):
                value=""
            for v in value:
                str1 = v + "," + str1
            if (str1 != "" and str1[-1] == ','):
                value = str1[:-1]

        return value

    # Export Tag fields - common code - Defined and Freeform Tags
    # header - individual headers/column name
    # values_for_column - list of columns from read_cd3 function
    def export_tags(oci_obj, header, values_for_column):
        defined_tags=""
        freeform_tags=""
        oke_labels=""
        if 'defined' in str(header).lower():
            if (oci_obj.__getattribute__('defined_tags')):
                for namespace, tags in oci_obj.__getattribute__('defined_tags').items():
                    for key, value in tags.items():
                        # Each Namespace/TagKey - Value pair ends with a ;
                        value = str(namespace + "." + key + "=" + value)
                        defined_tags=value+";"+defined_tags

            if (defined_tags != "" and defined_tags[-1] == ';'):
                defined_tags = defined_tags[:-1]
            values_for_column[header].append(defined_tags)

        elif 'free' in str(header).lower():
            if (oci_obj.__getattribute__('freeform_tags')):
                for keys, values in oci_obj.__getattribute__('freeform_tags').items():
                    value = str(keys + "=" + values)
                    freeform_tags= value + ';' +freeform_tags

            if (freeform_tags != '' and freeform_tags[-1] == ';'):
                freeform_tags = freeform_tags [:-1]
            values_for_column[header].append(freeform_tags)

        elif 'oke labels' in str(header).lower() or 'oke_labels' in str(header).lower():
            try:
                get_oke_labels = oci_obj.__getattribute__('initial_node_labels')
            except AttributeError as e:
                get_oke_labels = oci_obj.__getattribute__('initial_virtual_node_labels')

            for labels in get_oke_labels:
                value = str(labels.key + "=" + labels.value)
                oke_labels = oke_labels + ';' + value

            if (oke_labels != '' and oke_labels[0] == ';'):
                oke_labels = oke_labels[1:]
            values_for_column[header].append(oke_labels)

        return values_for_column

    #Export extra fields
    def export_extra_columns(oci_objs, col_header, sheet_dict, values_for_column):
        value = ""

        if (col_header in sheet_dict.keys()):
            # Check if property exists for any object on that sheet
            sheet_dict_val = sheet_dict[col_header]
            for oci_obj in oci_objs:
                try:
                    if "." in sheet_dict_val:
                        sheet_dict_vals = sheet_dict_val.split(".")
                        v=oci_obj
                        for l in range(0,len(sheet_dict_vals)):
                            if v is not None:
                                if (type(v) is list):
                                    v = v[0].__getattribute__(sheet_dict_vals[l])
                                else:
                                    v = v.__getattribute__(sheet_dict_vals[l])
                            else:
                                break

                        if v!='' and v is not None:
                            value = commonTools.check_exported_value(v)
                            break

                    else:
                        value = oci_obj.__getattribute__(sheet_dict[col_header])
                        value = commonTools.check_exported_value(value)
                        break
                except AttributeError as e:
                    pass
            values_for_column[col_header].append(value)
        # For Cols not defined in Excel_Columns sheet
        else:
            # Check if property exists for any object on that sheet
            for oci_obj in oci_objs:
                try:
                    value = oci_obj.__getattribute__(commonTools.check_column_headers(col_header))
                    value = commonTools.check_exported_value(value)
                    break
                except AttributeError as e:
                    pass
            values_for_column[col_header].append(value)

        return values_for_column

    # Check CD3 Column headers
    def check_column_headers(var_name):
        # replace special characters and spaces with '_' and convert to lowercase
        # replaces multiple occurrence of '_' to just 1
        var_name = var_name.strip()
        var_name = re.sub('[@!#$%^&*<>?/}{~: \n()|-]', '_', var_name).lower()
        var_name = re.sub('_+', '_', var_name).lower()
        return var_name

    #Check TF variable Name
    def check_tf_variable(var_name):
        tfname = re.compile('[^a-zA-Z0-9_-]')
        tfnamestart = re.compile('[A-Za-z]')

        var_name = tfname.sub("-", var_name)
        x = tfnamestart.match(var_name)
        # variable name doesnot start with letter; append with c
        if (x == None):
            var_name = "c" + var_name
        return var_name

    # Process ColumnValues
    def check_columnvalue(columnvalue):

        if str(columnvalue).lower() == 'true' or str(columnvalue).lower() == 'false':
            columnvalue = str(columnvalue).lower()

        if (columnvalue.lower() == 'nan'):
            columnvalue = ""

        # replace \ with \\
        if("\\" in columnvalue):
            columnvalue = columnvalue.replace("\\", "\\\\")

        # replace " with \"
        if("\"" in columnvalue):
            columnvalue=columnvalue.replace("\"","\\\"")

        return columnvalue

    # Process column values with ::
    def check_multivalues_columnvalue(columnvalue, columnname, tempdict):
        columnvalue = str(columnvalue).strip()
        columnname = commonTools.check_column_headers(columnname)
        if "::" in columnvalue:
            if ".Flex" in columnvalue or ".Micro" in columnvalue:
                columnname = commonTools.check_column_headers(columnname)
                multivalues = columnvalue.split("::")
                multivalues = [str(part).strip() for part in multivalues if part]
                tempdict = {columnname: multivalues}
            elif columnname != 'Compartment Name':
                columnname = commonTools.check_column_headers(columnname)
                multivalues = columnvalue.split("::")
                multivalues = [str(part).strip() for part in multivalues ]#if part]
                tempdict = {columnname: multivalues}
        return tempdict

    # Split values for tagging
    def split_tag_values(columnname, columnvalue, tempdict):
        columnvalue = columnvalue.replace("\n", "")
        if ";" in columnvalue:
            # If there are more than one tag; split them by ";" and "="
            columnname = commonTools.check_column_headers(columnname)
            multivalues = columnvalue.split(";")
            multivalues = [part.split("=") for part in multivalues if part]
            """for value in multivalues:
                try:
                    value[1] = value[1].replace("\\","\\\\")
                except IndexError as e:
                    pass"""
            tempdict = {columnname: multivalues}
        else:
            # If there is only one tag; split them only by "="; each key-value pair is stored as a list
            columnname = commonTools.check_column_headers(columnname)
            multivalues = columnvalue.split("=")
            multivalues = [str(part).strip() for part in multivalues if part]
            """if multivalues != []:
                try:
                    multivalues[1] = multivalues[1].replace("\\","\\\\")
                except IndexError as e:
                    pass"""
            tempdict = {columnname: [multivalues]}
        return tempdict

    # Read rows from CD3
    def read_cd3(cd3file, sheet_name):
        df = {}
        try:
            df = pd.read_excel(cd3file, sheet_name=sheet_name, skiprows=1, dtype=object)

        except Exception as e:
            if("Events" in str(e) or "Notifications" in str(e)):
                print("\nTabs - \"Events\" or \"Notifications\" is missing in the CD3. Please make sure to use the correct input file for Events and Notifications in properties file...Exiting!!")
                exit(1)
            else:
                print("Error occurred while reading the CD3 excel sheet: "+ str(e))
                exit(1)

        yield df
        try:
            book = load_workbook(cd3file)
            sheet = book[sheet_name]
        except KeyError as e:
            if 'does not exist' in str(e):
                print("\nTab - \""+sheet_name+"\" seems to be missing in the CD3. Please make sure to use the right CD3 in properties file.....Exiting!!")
                exit(1)
        except Exception as e:
            print(str(e))
            print("Exiting!!")
            exit(1)

        values_for_column = collections.OrderedDict()
        # values_for_column={}
        for j in range(0, sheet.max_column):
            col_name = sheet.cell(row=2, column=j + 1).value
            if (type(col_name) == str):
                values_for_column[col_name] = []
        yield values_for_column

    #Write exported  rows to cd3
    def write_to_cd3(values_for_column, cd3file, sheet_name,append=False):
        try:
            book = load_workbook(cd3file)
            sheet = book[sheet_name]
        except Exception as e:
            print(str(e))
            print("Exiting!!")
            exit(1)
        if (sheet_name == "VCN Info"):
            onprem_destinations = ""
            ngw_destinations = ""
            igw_destinations = ""
            for destination in values_for_column["onprem_destinations"]:
                onprem_destinations=destination+","+onprem_destinations
            for destination in values_for_column["ngw_destinations"]:
                ngw_destinations = destination + "," + ngw_destinations
            for destination in values_for_column["igw_destinations"]:
                igw_destinations = destination + "," + igw_destinations

            if (onprem_destinations != "" and onprem_destinations[-1] == ','):
                onprem_destinations = onprem_destinations[:-1]
            if (ngw_destinations != "" and ngw_destinations[-1] == ','):
                ngw_destinations = ngw_destinations[:-1]
            if (igw_destinations != "" and igw_destinations[-1] == ','):
                igw_destinations = igw_destinations[:-1]

            sheet.cell(3,2).value = onprem_destinations
            sheet.cell(4,2).value = ngw_destinations
            sheet.cell(5,2).value = igw_destinations
            try:
                book.save(cd3file)
                book.close()
            except Exception as e:
                print(str(e))
                print("Exiting!!")
                exit(1)
            return


        #rows_len=len(rows)
        rows_len = len(values_for_column["Region"])
        sheet_max_rows = sheet.max_row
        #If no rows exported from OCI, remove the sample data as well
        if(rows_len == 0) :
            if not append:
                print("0 rows exported; Nothing to write to CD3 excel; Tab "+sheet_name +" will be empty in CD3 excel!!")
                for i in range(0, sheet.max_row):
                    for j in range(0, sheet.max_column):
                        sheet.cell(row=i + 3, column=j + 1).value = ""
                try:
                    book.save(cd3file)
                    book.close()
                except Exception as e:
                    print(str(e))
                    print("Exiting!!")
                    exit(1)
            return

        if append:
            for x in range(1, sheet_max_rows):
                if sheet['A'][x].value == None:
                    last_line = x
                    break
            #rows_len +=last_line
            large = rows_len
            start = last_line+1


        else:
            start = 3
            if (rows_len > sheet_max_rows):
                large = rows_len
            else:
                large = sheet_max_rows

        df, values_for_column_sheet = commonTools.read_cd3(cd3file, sheet_name)

        #Put Data
        j=0
        for i in range(0,large):
            for col_name in values_for_column.keys():
                #Check if column name to be populated in present in the sheet.
                if col_name not in values_for_column_sheet:
                    continue
                # Data
                if(i>=rows_len):
                    sheet.cell(row=i+start, column=j+1).value = ""
                else:
                    sheet.cell(row=i+start, column=j+1).value = values_for_column[col_name][i]
                sheet.cell(row=i+start, column=j+1).alignment = Alignment(wrap_text=True)
                j=j+1
            j=0


        brdr = Border(left=Side(style='thin'),
                      right=Side(style='thin'),
                      top=Side(style='thin'),
                      bottom=Side(style='thin'),
                      )

        for row in sheet.iter_rows(min_row=3):
            for cell in row:
                cell.border = brdr

        # Add color for exported sec rules and route rules
        if (sheet_name == "RouteRulesinOCI" or sheet_name == "SecRulesinOCI" or sheet_name == "DRGRouteRulesinOCI"):
            names = []
            # Add color coding to exported rules
            for row in sheet.iter_rows(min_row=3):
                c = 0
                region = ""
                name = ""
                for cell in row:
                    c = c + 1
                    if (c == 1):
                        region = cell.value
                        continue
                    elif (c == 4):
                        name = cell.value
                        break

                vcn_name = region + "_" + name
                if (vcn_name not in names):
                    names.append(vcn_name)
                    for cellnew in row:
                        if (len(names) % 2 == 0):
                            cellnew.fill = PatternFill(start_color="94AFAF", end_color="94AFAF", fill_type="solid")
                            cellnew.border = brdr
                        else:
                            cellnew.fill = PatternFill(start_color="E5DBBE", end_color="E5DBBE", fill_type="solid")
                            cellnew.border = brdr
                else:
                    for cellnew in row:
                        if (len(names) % 2 == 0):
                            cellnew.fill = PatternFill(start_color="94AFAF", end_color="94AFAF", fill_type="solid")
                            cellnew.border = brdr
                        else:
                            cellnew.fill = PatternFill(start_color="E5DBBE", end_color="E5DBBE", fill_type="solid")
                            cellnew.border = brdr
        try:
            book.save(cd3file)
            book.close()
        except Exception as e:
            print(str(e))
            print("Exiting!!")
            exit(1)

    # def backup_file(src_dir, pattern, overwrite):
    def backup_file(src_dir, resource, pattern):
        dest_dir = str(src_dir) + "/backup_" + resource + "/" + datetime.datetime.now().strftime("%d-%m-%H%M%S").replace('/', '-')
        for f in os.listdir(str(src_dir)):
            if f.endswith(pattern):
                print("Backing up existing " + f + " to " + dest_dir)
                if not os.path.exists(dest_dir):
                    # print("\nCreating backup dir " + dest_dir + "\n")
                    os.makedirs(dest_dir)

                src = os.path.join(str(src_dir), f)
                #dest = os.path.join(dest_dir, f)
                # print("backing up ....." + src +"   to  "+dest)
                shutil.move(src, dest_dir)
                """if (overwrite == 'yes'):
                    shutil.move(src, dest_dir)
                elif (overwrite == 'no'):
                    shutil.copyfile(src, dest)
                """

    # def backup_file(src_dir, pattern, overwrite):
    def copy_file(src_dir, resource, pattern):
        dest_dir = str(src_dir) + "/backup_" + resource + "/" + datetime.datetime.now().strftime("%d-%m-%H%M%S").replace('/', '-')
        for f in os.listdir(str(src_dir)):
            if f.endswith(pattern):
                print("Backing up existing " + f + " to " + dest_dir)
                if not os.path.exists(dest_dir):
                    # print("\nCreating backup dir " + dest_dir + "\n")
                    os.makedirs(dest_dir)

                src = os.path.join(str(src_dir), f)
                # dest = os.path.join(dest_dir, f)
                # print("backing up ....." + src +"   to  "+dest)
                shutil.copy(src, dest_dir)

    # To copy data from *.auto.tfvars - Used in Modify Network - Seclist, RT, Def Seclist, Def RT to copy the rules/lists that is present in existing *.auto.tfvars
    def copy_data_from_file(self, outfile, region_comp_name, modifiedStr):
        start = "# Start of " + region_comp_name + " #"
        end = "# End of " + region_comp_name + " #"
        copy = False

        with open(outfile) as infile:
            for lines in infile:
                if start in lines:
                    modifiedStr = modifiedStr + "\n" + start + "\n"
                    copy = True
                elif end in lines:
                    modifiedStr = modifiedStr + "\n" + end + "\n"
                    copy = False
                elif copy:
                    modifiedStr = modifiedStr + lines
        return modifiedStr

    # Used in Modify SL
    def skipCommentedLine(self,lines):
        """
        A filter which skip/strip the comments and yield the
        rest of the lines
        :param lines: any object which we can iterate through such as a file
        object, list, tuple, or generator
        """
        for line in lines:
            comment_pattern = re.compile(r'\s*#.*$')
            line = re.sub(comment_pattern, '', line)
            if line:
                yield line

    def get_protocol(strprotocol):
        if str(strprotocol).lower() == "all":
            return "all"
        else:
            protocol_dict = commonTools().protocol_dict
            for k, v in protocol_dict.items():
                if (strprotocol).lower() == v.lower():
                    return k

    # Used in Modify SL, Default SL
    def create_ingress_rule_string(self, secrule, tempStr, ingress_rule, tempdict2, region_seclist_name):

        rule_desc = tempStr['rule_description']
        protocol = tempStr['protocol'].lower().strip()
        isstateless = str(tempStr['isstateless'].lower())
        if (str(rule_desc).lower() == "nan" or str(rule_desc).lower() == ""):
            rule_desc = ""
            tempdict2 ={'rule_description' : rule_desc}
        else:
            rule_desc = str(rule_desc)
            tempdict2 = {'rule_description': rule_desc}
        tempStr.update(tempdict2)

        if ("services-in-oracle-services-network" in tempStr['source'] or "objectstorage" in tempStr['source']):
            source_type = "SERVICE_CIDR_BLOCK"
            tempdict2 = {'source_type' : source_type}
        tempStr.update(tempdict2)

        tempdict2 = {'protocol_code': commonTools.get_protocol(protocol),'isstateless':isstateless}
        tempStr.update(tempdict2)

        ingress_rule = ingress_rule + secrule.render(tempStr)
        ingress_rule = ingress_rule + "\n" + "####ADD_NEW_INGRESS_SEC_RULES " + region_seclist_name + " ####"
        return ingress_rule

    # Used in Modify SL, Default SL
    def create_egress_rule_string(self, secrule, tempStr, egress_rule, tempdict2, region_seclist_name):

        rule_desc = tempStr['rule_description']
        protocol = tempStr['protocol'].lower().strip()
        isstateless = str(tempStr['isstateless'].lower())

        if (str(rule_desc).lower() == "nan"):
            rule_desc = ""
            tempdict2 ={'rule_description' : rule_desc}
        else:
            rule_desc = str(rule_desc)
            tempdict2 ={'rule_description' : rule_desc}
        tempStr.update(tempdict2)

        if ("services-in-oracle-services-network" in tempStr['destination'] or "objectstorage" in tempStr['destination']):
            destination_type = "SERVICE_CIDR_BLOCK"
            tempdict2 = {'destination_type': destination_type}
        tempStr.update(tempdict2)

        tempDict2 = {'protocol_code': commonTools.get_protocol(protocol),'isstateless':isstateless}
        tempStr.update(tempDict2)

        egress_rule = egress_rule + secrule.render(tempStr)
        egress_rule = egress_rule + "\n" + "####ADD_NEW_EGRESS_SEC_RULES " + region_seclist_name + " ####"
        return egress_rule


class parseDRGs():
    def __init__(self, filename):
        self.drg_names = {}
        self.drg_rds = {}
        try:
            # Read and search for VCN
            df_drgv2 = pd.read_excel(filename, sheet_name='DRGs', skiprows=1)
        except Exception as e:
            if ("No sheet named" in str(e)):
                print("\nTab - \"DRGs\" is missing in the CD3. Please make sure to use the right CD3 in properties file...Exiting!!")
                exit(1)
            else:
                print("Error occurred while reading the CD3 excel sheet " + str(e))
                exit(1)

        # Drop all empty rows
        df_drgv2 = df_drgv2.dropna(how='all')
        df_drgv2 = df_drgv2.reset_index(drop=True)

        # Create VCN details Dicts and Hub and Spoke VCN Names
        for i in df_drgv2.index:
            region = str(df_drgv2['Region'][i]).strip()
            if region in commonTools.endNames:  # or str(region).lower() == 'nan'):
                break
            drg_name = df_drgv2['DRG Name'][i]
            drg_name = str(drg_name).strip()
            region = region.lower()
            rd_name = str(df_drgv2['Import DRG Route Distribution Name'][i]).strip()

            self.drg_names.setdefault(region, [])

            if (drg_name not in self.drg_names[region]):
                self.drg_names[region].append(drg_name)
                key = drg_name,region
                self.drg_rds.setdefault(key,[])


            if rd_name!='' and rd_name.lower()!='nan':
                self.drg_rds[drg_name,region].append(rd_name)


# NOTE: Does this really need to be a class? its an obsfucated function call.
class parseVCNs():
    def __init__(self, filename):
        self.peering_dict = dict()

        self.vcn_region = {}
        self.vcn_drgs = {}
        self.vcn_drg_names = {}
        self.vcn_compartment = {}
        self.vcn_lpg_names = {}
        self.vcn_lpg_names1 = {}
        self.vcn_lpg_names2 = {}
        self.vcn_lpg_names3 = {}
        self.hub_vcn_names = []
        self.spoke_vcn_names = []
        self.vcn_lpg_rules = {}
        self.vcn_igws = {}
        self.vcn_ngws = {}
        self.vcn_sgws = {}
        self.vcn_hub_spoke_peer_none = {}
        self.vcn_compartment = {}
        self.vcn_names = []
        self.vcn_cidrs = {}
        self.vcns_having_drg = {}

        try:
            # Read and search for VCN
            df_vcn = pd.read_excel(filename, sheet_name='VCNs', skiprows=1)
        except Exception as e:
            if ("No sheet named" in str(e)):
                print("\nTab - \"VCNs\" is missing in the CD3. Please make sure to use the right CD3 in properties file...Exiting!!")
                exit(1)
            else:
                print("Error occurred while reading the CD3 excel sheet " + str(e))
                exit(1)


        # Drop all empty rows
        df_vcn = df_vcn.dropna(how='all')
        df_vcn = df_vcn.reset_index(drop=True)

        # Create VCN details Dicts and Hub and Spoke VCN Names
        for i in df_vcn.index:
            region = str(df_vcn['Region'][i]).strip()
            if region in commonTools.endNames:  # or str(region).lower() == 'nan'):
                break
            vcn_name = df_vcn['VCN Name'][i]
            vcn_name = str(vcn_name).strip()
            region = str(region).strip().lower()

            entry = vcn_name,region
            self.vcn_names.append(entry)

            if str(df_vcn['Hub/Spoke/Peer/None'][i]).strip().split(":")[0].strip().lower() == 'hub':
                self.peering_dict[vcn_name,region] = ""


        for i in df_vcn.index:
            region = str(df_vcn['Region'][i]).strip()
            if (region in commonTools.endNames):  # or str(region).lower()=='nan'):
                break
            vcn_name = df_vcn['VCN Name'][i]
            vcn_name = str(vcn_name).strip()

            region = str(region).strip().lower()
            #self.vcn_region[vcn_name] = region

            self.vcn_lpg_names[vcn_name,region] = str(df_vcn['LPG Required'][i]).strip().split(",")
            self.vcn_lpg_names[vcn_name,region] = [x.strip() for x in self.vcn_lpg_names[vcn_name,region]]

            j = 0
            for lpg in self.vcn_lpg_names[vcn_name,region]:
                if lpg == 'y':
                    self.vcn_lpg_names[vcn_name,region][j] = vcn_name + "_lpg" + str(j)
                    j = j + 1
            self.vcn_lpg_names1[vcn_name,region] = str(df_vcn['LPG Required'][i]).strip().split(",")
            self.vcn_lpg_names1[vcn_name,region] = [x.strip() for x in self.vcn_lpg_names1[vcn_name,region]]

            j = 0
            for lpg in self.vcn_lpg_names1[vcn_name,region]:
                if lpg == 'y':
                    self.vcn_lpg_names1[vcn_name,region][j] = vcn_name + "_lpg" + str(j)
                    j = j + 1

            self.vcn_lpg_names2[vcn_name,region] = str(df_vcn['LPG Required'][i]).strip().split(",")
            self.vcn_lpg_names2[vcn_name,region] = [x.strip() for x in self.vcn_lpg_names2[vcn_name,region]]

            j = 0
            for lpg in self.vcn_lpg_names2[vcn_name,region]:
                if lpg == 'y':
                    self.vcn_lpg_names2[vcn_name,region][j] = vcn_name + "_lpg" + str(j)
                    j = j + 1

            self.vcn_lpg_names3[vcn_name,region] = str(df_vcn['LPG Required'][i]).strip().split(",")
            self.vcn_lpg_names3[vcn_name,region] = [x.strip() for x in self.vcn_lpg_names3[vcn_name,region]]

            j = 0
            for lpg in self.vcn_lpg_names3[vcn_name,region]:
                if lpg == 'y':
                    self.vcn_lpg_names3[vcn_name,region][j] = vcn_name + "_lpg" + str(j)
                    j = j + 1


            drg_required = str(df_vcn['DRG Required'][i]).strip().split("::")
            if (len(drg_required)==2):
                self.vcn_drgs[vcn_name, region] = [str(drg_required[0]).strip(),str(drg_required[1]).strip()]
            else:
                self.vcn_drgs[vcn_name, region] = [str(drg_required[0]).strip(),'']

            if(str(drg_required[0]).strip().lower() != 'n'):
                if (str(drg_required[0]).strip().lower() == "y"):
                    drg_name = region + "_drg"
                # use name provided in input
                else:
                    drg_name = str(drg_required[0]).strip()

                self.vcns_having_drg[vcn_name,region]=drg_name

            self.vcn_cidrs[vcn_name,region]=str(df_vcn['CIDR Blocks'][i]).strip()
            #cidr_blocks = [x.strip() for x in columnvalue.split(',')]

            igw_required = str(df_vcn['IGW Required'][i]).strip().split("::")
            if (len(igw_required)==2):
                self.vcn_igws[vcn_name, region] = [str(igw_required[0].strip()),str(igw_required[1]).strip()]
            else:
                self.vcn_igws[vcn_name, region] = [str(igw_required[0]).strip(),'']

            ngw_required = str(df_vcn['NGW Required'][i]).strip().split("::")
            if (len(ngw_required) == 2):
                self.vcn_ngws[vcn_name, region] = [str(ngw_required[0]).strip(), str(ngw_required[1]).strip()]
            else:
                self.vcn_ngws[vcn_name, region] = [str(ngw_required[0]).strip(), '']

            sgw_required = str(df_vcn['SGW Required'][i]).strip().split("::")
            if (len(sgw_required) == 2):
                self.vcn_sgws[vcn_name, region] = [str(sgw_required[0]).strip(), str(sgw_required[1]).strip()]
            else:
                self.vcn_sgws[vcn_name, region] = [str(sgw_required[0]).strip(), '']

            self.vcn_hub_spoke_peer_none[vcn_name,region] = str(df_vcn['Hub/Spoke/Peer/None'][i]).strip().split(":")

            self.vcn_compartment[vcn_name,region] = str(df_vcn['Compartment Name'][i]).strip()
            self.vcn_lpg_rules.setdefault((vcn_name,region), '')

            if (self.vcn_hub_spoke_peer_none[vcn_name,region][0].strip().lower() == 'hub'):
                entry=vcn_name,region
                self.hub_vcn_names.append(entry)

            if (self.vcn_hub_spoke_peer_none[vcn_name,region][0].strip().lower() == 'spoke'):
                hub_name = self.vcn_hub_spoke_peer_none[vcn_name,region][1].strip()
                entry = vcn_name, region
                self.spoke_vcn_names.append(entry)
                try:
                    self.peering_dict[hub_name,region] = self.peering_dict[hub_name,region] + vcn_name + ","
                except KeyError:
                    print("ERROR!!! "+hub_name +" not marked as Hub. Verify hub_spoke_peer_none column again..Exiting!")
                    exit(1)

            if (self.vcn_hub_spoke_peer_none[vcn_name,region][0].strip().lower() == 'peer'):
                self.peering_dict[vcn_name,region] = self.vcn_hub_spoke_peer_none[vcn_name,region][1].strip()


        for k, v in self.peering_dict.items():
            if (v != "" and v[-1] == ','):
                v = v[:-1]
                self.peering_dict[k] = v

@contextmanager
def section(title='', header=False, padding=117):
    separator = '-' if not header else '='
    # Not sure why 117 but thats how it was before.
    print(f'{title:{separator}^{padding}}')
    yield
    if header:
        print(separator * padding)


def exit_menu(msg, exit_code=1):
    print(msg)
    exit(exit_code)


class parseVCNInfo():
    # all_regions = []

    def __init__(self, filename):
        self.onprem_destinations = []
        self.ngw_destinations = []
        self.igw_destinations = []
        try:
            df_info = pd.read_excel(filename, sheet_name='VCN Info', skiprows=1)
        except Exception as e:
            if ("No sheet named" in str(e)):
                print("\nTab - \"VCN Info\" is missing in the CD3. Please make sure to use the right CD3 in properties file...Exiting!!")
                exit(1)
            else:
                print("Error occurred while reading the CD3 excel sheet "+ str(e))
                exit(1)
        # Get Property Values
        values = df_info['Value']

        onprem_destinations = str(values[0]).strip()
        if (onprem_destinations.lower() == 'nan'):
            # print("\ndrg_subnet should not be left empty.. It will create empty route tables")
            self.onprem_destinations.append('')
        else:
            self.onprem_destinations = onprem_destinations.split(",")

        ngw_destinations = str(values[1]).strip()
        if (ngw_destinations.lower() == 'nan'):
            self.ngw_destinations.append('0.0.0.0/0')
        else:
            self.ngw_destinations = ngw_destinations.split(",")

        igw_destinations = str(values[2]).strip()
        if (igw_destinations.lower() == 'nan'):
            self.igw_destinations.append('0.0.0.0/0')
        else:
            self.igw_destinations = igw_destinations.split(",")


class parseSubnets():
    def __init__(self, filename):
        self.vcn_subnet_map = {}
        try:
            # Read and search for VCN
            df_subnet = pd.read_excel(filename, sheet_name='SubnetsVLANs', skiprows=1)
        except Exception as e:
            if ("No sheet named" in str(e)):
                print("\nTab - \"SubnetsVLANs\" is missing in the CD3. Please make sure to use the right CD3 in properties file...Exiting!!")
                exit(1)
            else:
                print("Error occurred while reading the CD3 excel sheet " + str(e))
                exit(1)

        # Drop all empty rows
        df_subnet = df_subnet.dropna(how='all')
        df_subnet = df_subnet.reset_index(drop=True)


        for i in df_subnet.index:
            region = str(df_subnet['Region'][i]).strip()
            if (region in commonTools.endNames):  # or str(region).lower()=='nan'):
                break
            key = df_subnet.loc[i,'Region'].strip().lower(),df_subnet.loc[i,'VCN Name'].strip()+"_"+df_subnet.loc[i,'Display Name'].strip()
            value = df_subnet.loc[i,'Compartment Name'].strip(), df_subnet.loc[i,'VCN Name'].strip(), df_subnet.loc[i,'Display Name'].strip()
            self.vcn_subnet_map[key] =  value

class cd3Services():


    #Get OCI Cloud Regions
    regions_list = ""
    def fetch_regions(self,config,signer):
        #config = oci.config.from_file(file_location=configFileName)
        idc = IdentityClient(config=config, retry_strategy=oci.retry.DEFAULT_RETRY_STRATEGY,signer=signer)
        try:
            regions_list = idc.list_regions().data
        except Exception as e:
            print(e)
            if ('NotAuthenticated' in str(e)):
                print("\nInvalid Credetials - check your keypair/fingerprint/region...Exiting!!!")
                exit(1)

        if ("OCSWorkVM" in os.getcwd() or 'user-scripts' in os.getcwd()):
            os.chdir("../")

        tempStr = '#Region:Region_Key\n'
        for reg in regions_list:
            cd3key = str(reg.name.split('-')[1]).lower()
            name = str(reg.name).lower()
            line = cd3key + ":" + name
            tempStr = tempStr + line + '\n'

        with open('OCI_Regions', 'w+') as f:
            f.write(tempStr)
        f.close()
        print("Updated OCI_Regions file !!!\n")

    # Parse XML - Used by OCI Protocols
    def parse_xml(source: str) -> ET.Element:
        it = ET.iterparse(open(source))
        # strip namespaces
        for _, el in it:
            if "}" in el.tag:
                el.tag = el.tag.split("}", 1)[1]
        root = it.root  # mypy: ignore
        return root

    # Parse Date - Used by OCI Protocols
    def parse_date(root_xml: ET.Element) -> datetime:
        updated = root_xml.find("updated")
        assert updated is not None and isinstance(updated.text, str)
        return datetime.datetime.strptime(updated.text, "%Y-%m-%d")

    # write_protocols_file - Used for OCI Protocols
    def write_protocols_file(source: str, destination: str) -> datetime:
        root = cd3Services.parse_xml(source)
        updated = cd3Services.parse_date(root)
        destination = str(pathlib.Path.cwd())+"/"+destination
        with open(destination,"w+") as dst:
            dst.write("#protocol number:protocol name\n")
            for r in root.iter("record"):
                desc_ = r.find("description")
                if desc_ is None or desc_.text is None:
                    desc = ""
                else:
                    desc = desc_.text
                name_ = r.find("name")
                value_ = r.find("value")
                if (value_ is None
                    or value_.text is None):
                    continue
                if (name_ is None
                    or name_.text is None):
                    name = desc
                    dst.write(str(value_.text) + ":" + name + "\n")
                    continue
                alias = name_.text.split()[0]
                value = int(value_.text)
                dst.write(str(value)+":"+alias+"\n")
        return updated

    def download(url: str, path: str) -> None:
        with open(path, "wb") as dst, urllib.request.urlopen(url) as src:
            shutil.copyfileobj(src, dst)

    #Get OCI Protocols
    def fetch_protocols(self) -> None:

        ssl._create_default_https_context = ssl._create_unverified_context
        PROTOCOLS_URL = "https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xml"
        PROTOCOLS_XML = "protocol-numbers.xml"
        PROTOCOLS_FILE = "OCI_Protocols"

        ##### main code for oci protocols ####
        protocols_xml = str(pathlib.Path.cwd()) + "/" + PROTOCOLS_XML
        try:
            cd3Services.download(PROTOCOLS_URL, protocols_xml)
        except OSError as e:
            print("Could not download iana service names and port numbers: {}".format(e),
                  file=sys.stderr,
                  )
            sys.exit(1)
        cd3Services.write_protocols_file(protocols_xml, PROTOCOLS_FILE)
        rem_file = pathlib.Path(protocols_xml)
        rem_file.unlink()

        print("Updated OCI_Protocols file !!!\n")